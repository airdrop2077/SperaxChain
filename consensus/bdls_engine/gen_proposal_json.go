// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package bdls_engine

import (
	"encoding/json"
	"errors"
	"math/big"

	"github.com/Sperax/SperaxChain/common/hexutil"
	"github.com/Sperax/SperaxChain/core/types"
)

var _ = (*proposalMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (p Proposal) MarshalJSON() ([]byte, error) {
	type Proposal struct {
		Block       *types.Block    `json:"block"    gencodec:"required"`
		MerkleProof []hexutil.Bytes `json:"merkleProof"    gencodec:"required"`
		V           *hexutil.Big    `json:"v" gencodec:"required"`
		R           *hexutil.Big    `json:"r" gencodec:"required"`
		S           *hexutil.Big    `json:"s" gencodec:"required"`
	}
	var enc Proposal
	enc.Block = p.Block
	if p.MerkleProof != nil {
		enc.MerkleProof = make([]hexutil.Bytes, len(p.MerkleProof))
		for k, v := range p.MerkleProof {
			enc.MerkleProof[k] = v
		}
	}
	enc.V = (*hexutil.Big)(p.V)
	enc.R = (*hexutil.Big)(p.R)
	enc.S = (*hexutil.Big)(p.S)
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (p *Proposal) UnmarshalJSON(input []byte) error {
	type Proposal struct {
		Block       *types.Block    `json:"block"    gencodec:"required"`
		MerkleProof []hexutil.Bytes `json:"merkleProof"    gencodec:"required"`
		V           *hexutil.Big    `json:"v" gencodec:"required"`
		R           *hexutil.Big    `json:"r" gencodec:"required"`
		S           *hexutil.Big    `json:"s" gencodec:"required"`
	}
	var dec Proposal
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Block == nil {
		return errors.New("missing required field 'block' for Proposal")
	}
	p.Block = dec.Block
	if dec.MerkleProof == nil {
		return errors.New("missing required field 'merkleProof' for Proposal")
	}
	p.MerkleProof = make([][]byte, len(dec.MerkleProof))
	for k, v := range dec.MerkleProof {
		p.MerkleProof[k] = v
	}
	if dec.V == nil {
		return errors.New("missing required field 'v' for Proposal")
	}
	p.V = (*big.Int)(dec.V)
	if dec.R == nil {
		return errors.New("missing required field 'r' for Proposal")
	}
	p.R = (*big.Int)(dec.R)
	if dec.S == nil {
		return errors.New("missing required field 's' for Proposal")
	}
	p.S = (*big.Int)(dec.S)
	return nil
}
